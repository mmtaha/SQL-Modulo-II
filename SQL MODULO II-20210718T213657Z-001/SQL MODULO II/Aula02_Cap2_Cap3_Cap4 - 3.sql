--IDENTITY(AUTONUMERAÇÃO)
CREATE DATABASE TESTE_IDENTITY
--COLOCAR O BANCO DE DADOS EM USO
USE TESTE_IDENTITY
--CRIAR A TABELA PROFESSOR
CREATE TABLE PROFESSOR
( COD_PROF INT IDENTITY(1,1)
,NOME VARCHAR(30)
,CONSTRAINT PK_PROFESSOR PRIMARY KEY (COD_PROF) )

CREATE TABLE ALUNO
( COD_ALUNO INT IDENTITY(10,2)
,NOME VARCHAR(30)
,CONSTRAINT PK_ALUNO PRIMARY KEY (COD_ALUNO) 
SELECT *
FROM PROFESSOR 

INSERT PROFESSOR 
VALUES ('MAGNO')
      ,('AGNALDO')
      ,('ROBERTO')
      ,('RENATA')
      ,('EDUARDO')
      ,('MARCIO')

SELECT *
FROM ALUNO

-- Inserir dados na tabela ALUNO
INSERT ALUNO 
VALUES ('ZÉ DA SILVA'),('CARLOS P. SILVA'),
('ITAMAR COSTA')
--APAGAR O REGISTRO DE CODIGO 2 NA TABELA 
--PROFESSOR
BEGIN TRAN
DELETE
FROM PROFESSOR
WHERE COD_PROF=2

SELECT *
FROM PROFESSOR
--PERMITIR A INSERÇÃO COM O IDENTITY
SET IDENTITY_INSERT PROFESSOR ON 
--INSERT DECLARATIVO
INSERT INTO PROFESSOR(COD_PROF 
                      ,NOME)
VALUES(2,'MARIA ANTONIA')
SET IDENTITY_INSERT PROFESSOR OFF
COMMIT
--APAGAR O REGISTRO QUE TEM O NOME RENATA
DELETE 
FROM PROFESSOR 
WHERE COD_PROF=4
--INSERIR UM REGISTRO QUE TENHA O MESMO CODIGO
--DA PROFESSORA RENATA
SET IDENTITY_INSERT PROFESSOR ON
INSERT INTO PROFESSOR(COD_PROF
                      ,NOME)
VALUES(4,'VAGNER')
SELECT *
FROM PROFESSOR 
SET IDENTITY_INSERT PROFESSOR OFF
--IDENTIFICAR A COLUNA COM AUTONUMERAÇÃO
SELECT IDENTITYCOL FROM PROFESSOR
SELECT IDENTITYCOL FROM ALUNO
------------------------------------------------
--VALOR INICIAL DO IDENTITY
SELECT IDENT_SEED('PROFESSOR')
--INCREMENTO DO IDENTITY
SELECT IDENT_INCR('PROFESSOR')
--APRESENTE O VALOR INICIAL DO IDENTITY PARA
--A TABELA ALUNO
SELECT IDENT_SEED('ALUNO')
--APRESENTE O VALOR INCREMENTO DO IDENTITY PARA
--A TABELA ALUNO
SELECT IDENT_INCR('ALUNO')
-----------------------------------------------
SELECT SCOPE_IDENTITY()
SELECT @@IDENTITY
-----------------------------------------------
--ULTIMO VALOR AUTONUMERAÇÃO DE UMA TABELA
SELECT IDENT_CURRENT ('PROFESSOR')
SELECT IDENT_CURRENT ('ALUNO')
-----------------------------------------------
--APAGAR TODOS OS REGISTROS DA TABELA PROFESSOR
DELETE
FROM PROFESSOR

SELECT *
FROM PROFESSOR 
INSERT INTO PROFESSOR
VALUES('JANAINA')
--REINICIAR O AUTONUMERAÇÃO(IDENTITY)
DELETE
FROM PROFESSOR
DBCC CHECKIDENT('PROFESSOR',RESEED,0)

SELECT *
FROM PROFESSOR
--VISUALIZAR A ESTRUTURA DA TABELA
EXEC SP_HELP PROFESSOR
-------------------------------------------
--COLOCAR EM USO O BANCO DE DADOS PEDIDOS
USE Pedidos
--COPIA DA TABELA EMPREGADO
SELECT * INTO EMP_TEMP
FROM TB_EMPREGADO 

SELECT *
FROM EMP_TEMP
--APAGAR OS REGISTROS COM COD_CARGO=3
DELETE
FROM EMP_TEMP
OUTPUT deleted.*
WHERE COD_CARGO=3
------------------------------------------------
UPDATE EMP_TEMP 
SET SALARIO = SALARIO * 1.0
OUTPUT deleted.*
WHERE COD_DEPTO = 2
SET IDENTITY_INSERT EMP_TEMP ON
SELECT COUNT(*)
FROM EMP_TEMP
SELECT COUNT(*)
FROM TB_EMPREGADO
--AS TABELAS EMP_TEMP E TB_EMPREGADO DEVEM SER
--IGUAIS, OU SEJA, TER A MESMA QUANTIDADE DE 
--REGISTROS E O MESMO CONTEUDO PARA OS CAMPOS
--EMP_TEMP É A TABELA ALVO
--TB_EMPREGADO É A TABELA FONTE
SET IDENTITY_INSERT EMP_TEMP ON
MERGE EMP_TEMP AS EMP
USING TB_EMPREGADO AS TB_EMP
ON EMP.CODFUN=TB_EMP.CODFUN
WHEN MATCHED AND EMP.SALARIO<>TB_EMP.SALARIO THEN
UPDATE
SET EMP.SALARIO=TB_EMP.SALARIO

WHEN NOT MATCHED THEN
INSERT (CODFUN,NOME,COD_DEPTO
       ,COD_CARGO,DATA_ADMISSAO
       ,DATA_NASCIMENTO,SALARIO
       , NUM_DEPEND, SINDICALIZADO
       , OBS, FOTO)
VALUES (CODFUN,NOME,COD_DEPTO
        ,COD_CARGO,DATA_ADMISSAO
        ,DATA_NASCIMENTO,SALARIO
        , NUM_DEPEND, SINDICALIZADO
        , OBS, FOTO);
SET IDENTITY_INSERT EMP_TEMP OFF
--
SELECT *
FROM SYSOBJECTS
WHERE XTYPE='U'
SELECT *
FROM SYS.OBJECTS
WHERE OBJECT_ID=1454628225
--APAGAR A TABELA EMP_TEMP
IF OBJECT_ID('EMP_TEMP','U') IS NOT NULL
DROP TABLE EMP_TEMP
SELECT * INTO EMP_TEMP
FROM TB_EMPREGADO
------------------------------------------------
--MEREGE COM OUTPUT
--PREPARAR A TABELA EMP_TEMP
DELETE 
FROM EMP_TEMP 
WHERE COD_CARGO IN (3,5,7)
-------------------------------------------------
UPDATE EMP_TEMP 
SET SALARIO *= 1.2
WHERE COD_DEPTO = 2
-------------------------------------------------
INSERT INTO EMP_TEMP
(NOME, COD_DEPTO, COD_CARGO
,SALARIO, DATA_ADMISSAO)
VALUES ('MARIA ANTONIA',1,2
        ,2000,GETDATE())
       ,('ANTONIA MARIA',2,1,3000,GETDATE())
SELECT *
FROM EMP_TEMP
ORDER BY CODFUN 
SET IDENTITY_INSERT EMP_TEMP ON
MERGE EMP_TEMP AS EMPT
USING TB_EMPREGADO AS EMP
ON EMPT.CODFUN=EMP.CODFUN

WHEN MATCHED AND EMPT.SALARIO <> EMP.SALARIO THEN
UPDATE 
SET EMPT.SALARIO=EMP.SALARIO

WHEN NOT MATCHED THEN
INSERT (CODFUN,NOME,COD_DEPTO
       ,COD_CARGO,DATA_ADMISSAO
       , DATA_NASCIMENTO
       ,SALARIO, NUM_DEPEND
       , SINDICALIZADO, OBS, FOTO)
VALUES (CODFUN,NOME,COD_DEPTO,COD_CARGO
       ,DATA_ADMISSAO, DATA_NASCIMENTO
       ,SALARIO, NUM_DEPEND, SINDICALIZADO
       , OBS, FOTO)
WHEN NOT MATCHED BY SOURCE THEN
DELETE 
OUTPUT $ACTION AS ACAO
      ,INSERTED.CODFUN AS [Código Após]
      ,DELETED.CODFUN AS [Código Antes]
      ,INSERTED.NOME AS [Nome Após]
      ,DELETED.NOME AS [Nome Antes]
      ,INSERTED.SALARIO AS [Salário Após]
      ,DELETED.SALARIO AS [Salário Antes];
SET IDENTITY_INSERT EMP_TEMP OFF
-----------------------------------------------
--PIVOT
SELECT CODVEN
     , MONTH(DATA_EMISSAO) AS MES
     , YEAR(DATA_EMISSAO) AS ANO
     , SUM(VLR_TOTAL) AS TOT_VENDIDO
FROM TB_PEDIDO
WHERE YEAR(DATA_EMISSAO) = 2014
GROUP BY CODVEN , MONTH(DATA_EMISSAO)
       , YEAR(DATA_EMISSAO)
ORDER BY 1,2,3
---------------------------------------------
SELECT CODVEN,[1] AS JAN, [2] AS FEV
             ,[3] AS MAR, [4] AS ABR
             ,[5] AS MAI, [6] AS JUN
             ,[7] AS JUL, [8] AS AGO
             ,[9] AS [SET], [10] AS [OUT]
             ,[11] AS NOV, [12] AS DEZ
FROM(SELECT CODVEN,VLR_TOTAL,MONTH(DATA_EMISSAO) AS MES
     FROM TB_PEDIDO AS PED
     WHERE YEAR(DATA_EMISSAO)=2014) AS DADOS
PIVOT(SUM(VLR_TOTAL) FOR MES IN ([1],[2],[3]
															,[4],[5],[6]
															,[7],[8],[9]
												,[10],[11],[12])) AS GIRO
----------------------------------------------------------------------
--EXERCICIO
--ACRESCENTAR O CAMPO NOME DO VENDEDOR
SELECT CODVEN, NOME, [1] AS JAN, [2] AS FEV
             ,[3] AS MAR, [4] AS ABR
             ,[5] AS MAI, [6] AS JUN
             ,[7] AS JUL, [8] AS AGO
             ,[9] AS [SET], [10] AS [OUT]
             ,[11] AS NOV, [12] AS DEZ
FROM(SELECT PED.CODVEN, VEND.NOME,PED.VLR_TOTAL
           ,MONTH(PED.DATA_EMISSAO) AS MES
     FROM TB_PEDIDO AS PED
     INNER JOIN TB_VENDEDOR AS VEND
     ON VEND.CODVEN=PED.CODVEN
     WHERE YEAR(DATA_EMISSAO)=2014) AS DADOS
PIVOT(SUM(VLR_TOTAL) FOR MES IN ([1],[2],[3]
															,[4],[5],[6]
															,[7],[8],[9]
												,[10],[11],[12])) AS GIRO

--CRIAR UMA CONSULTA PARA RETORNAR O TOTAL PEDIDO(VLR_TOTAL) POR CLIENTE
--NO ANO DE 2014 NOS MESES DE JAN A DEZ

SELECT CODCLI, NOME, [1] AS JAN, [2] AS FEV
             ,[3] AS MAR, [4] AS ABR
             ,[5] AS MAI, [6] AS JUN
             ,[7] AS JUL, [8] AS AGO
             ,[9] AS [SET], [10] AS [OUT]
             ,[11] AS NOV, [12] AS DEZ
FROM(SELECT CLI.CODCLI, CLI.NOME,PED.VLR_TOTAL
           ,MONTH(PED.DATA_EMISSAO) AS MES
     FROM TB_PEDIDO AS PED
     INNER JOIN TB_CLIENTE AS CLI
     ON CLI.CODCLI=PED.CODCLI
     WHERE YEAR(DATA_EMISSAO)=2014) AS DADOS
PIVOT(SUM(VLR_TOTAL) FOR MES IN ([1],[2],[3]
															,[4],[5],[6]
															,[7],[8],[9]
												,[10],[11],[12])) AS GIRO

--UNPIVOT
CREATE TABLE FREQ_CINEMA
( DIA_SEMANA TINYINT,
SEC_14HS INT,
SEC_16HS INT,
SEC_18HS INT,
SEC_20HS INT,
SEC_22HS INT )

INSERT FREQ_CINEMA VALUES ( 1, 80, 100, 130, 90, 70 )
INSERT FREQ_CINEMA VALUES ( 2, 20, 34, 75, 50, 30 )
INSERT FREQ_CINEMA VALUES ( 3, 25, 40, 80, 70, 25 )
INSERT FREQ_CINEMA VALUES ( 4, 30, 45, 70, 50, 30 )
INSERT FREQ_CINEMA VALUES ( 5, 35, 40, 60, 60, 40 )
INSERT FREQ_CINEMA VALUES ( 6, 25, 34, 70, 90, 110 )
INSERT FREQ_CINEMA VALUES ( 7, 30, 80, 130, 150, 180 )

SELECT *
FROM FREQ_CINEMA
----------------------------------------------------------

SELECT DIA_SEMANA, HORARIO, QTD_PESSOAS
FROM (SELECT DIA_SEMANA
           , SEC_14HS
           , SEC_16HS
           , SEC_18HS
           , SEC_20HS
           , SEC_22HS
FROM FREQ_CINEMA) AS DADOS_CINE
UNPIVOT ( QTD_PESSOAS FOR HORARIO IN (SEC_14HS, SEC_16HS, SEC_18HS,
                                      SEC_20HS, SEC_22HS)) AS GIRO
-------------------------------------------------------------------------
SELECT MONTH( DATA_EMISSAO ) AS MES
      ,YEAR( DATA_EMISSAO ) AS ANO
      ,MAX( VLR_TOTAL ) AS MAIOR_PEDIDO
FROM TB_PEDIDO
WHERE YEAR(DATA_EMISSAO) = 2014
GROUP BY MONTH(DATA_EMISSAO), YEAR(DATA_EMISSAO)
ORDER BY 1
---CTE
WITH BUSCAPED (MES, ANO,MAIOR_PEDIDO)
AS
(
SELECT MONTH( DATA_EMISSAO ) AS MES
      ,YEAR( DATA_EMISSAO ) AS ANO
      ,MAX( VLR_TOTAL ) AS MAIOR_PEDIDO
FROM TB_PEDIDO
WHERE YEAR(DATA_EMISSAO) = 2014
GROUP BY MONTH(DATA_EMISSAO), YEAR(DATA_EMISSAO)
)

SELECT BUSCAPED.MES
      ,BUSCAPED.ANO
      ,BUSCAPED.MAIOR_PEDIDO
      ,TB_PEDIDO.NUM_PEDIDO
FROM BUSCAPED
INNER JOIN TB_PEDIDO
ON BUSCAPED.MES=MONTH(TB_PEDIDO.DATA_EMISSAO )
AND BUSCAPED.ANO=YEAR(TB_PEDIDO.DATA_EMISSAO )
AND BUSCAPED.MAIOR_PEDIDO=TB_PEDIDO.VLR_TOTAL

--CTE RECURSIVA
WITH CONTADOR(N)
AS
(
SELECT 1
UNION ALL
SELECT N+1 FROM CONTADOR
WHERE N<10
)
SELECT *
FROM CONTADOR
--CROSS APPLY
SELECT C.CODCLI, C.NOME,P.NUM_PEDIDO
      ,P.VLR_TOTAL, P.DATA_EMISSAO
      , (SELECT COUNT(*) 
         FROM TB_PEDIDO
         WHERE CODCLI = C.CODCLI) AS QTD_PED
       ,(SELECT MAX(VLR_TOTAL) FROM TB_PEDIDO
         WHERE CODCLI = C.CODCLI) AS MAIOR_VALOR
FROM TB_CLIENTE AS C
JOIN TB_PEDIDO AS P ON P.CODCLI = C.CODCLI
ORDER BY C.CODCLI,P.NUM_PEDIDO
--CROSS APPLY
SELECT C.CODCLI,C.NOME,P.NUM_PEDIDO
      ,P.VLR_TOTAL, P.DATA_EMISSAO
      ,CR.QTD_PED, CR.MAIOR_VALOR
FROM TB_CLIENTE AS C
JOIN TB_PEDIDO AS P 
ON P.CODCLI = C.CODCLI

CROSS APPLY
( SELECT COUNT(*) AS QTD_PED
         ,MAX(VLR_TOTAL) AS MAIOR_VALOR
  FROM TB_PEDIDO AS P
  WHERE C.CODCLI=P.CODCLI ) AS CR
ORDER BY CR.QTD_PED

SELECT D.DEPTO , E.NOME
FROM TB_DEPARTAMENTO AS D
JOIN TB_EMPREGADO AS E 
ON E.COD_DEPTO = D.COD_DEPTO
ORDER BY E.NOME


SELECT D.DEPTO , CA.NOME
FROM TB_DEPARTAMENTO AS D
CROSS APPLY
(SELECT E.NOME 
FROM TB_EMPREGADO AS E 
WHERE E.COD_DEPTO = D.COD_DEPTO ) AS CA
ORDER BY CA.NOME
-----------------------------------------------------------------------

SELECT D.DEPTO , E.NOME
FROM TB_DEPARTAMENTO AS D LEFT JOIN TB_EMPREGADO AS E 
ON E.COD_DEPTO = D.COD_DEPTO
ORDER BY 2

--OUTER APPLY

SELECT D.DEPTO , CA.NOME
FROM TB_DEPARTAMENTO AS D
OUTER APPLY
(SELECT E.NOME 
FROM TB_EMPREGADO AS E 
WHERE E.COD_DEPTO = D.COD_DEPTO ) AS CA
ORDER BY 2
-------------------------------------------------------------------------
--EXERCICIO LAB2 A, B,C
-------------------------------------------------------------------------
--CAPITULO 3 - TIPOS DE DADOS
--CRIAR OS TIPOS DE DADOS:
--TIPO_NOME --> VARCHAR(60)
--TIPO_ENDERECO --> VARCHAR(60)

CREATE TYPE TIPO_NOME
FROM VARCHAR(60) NOT NULL
--VISUALIZAR O TIPO DE DADOS CRIADO PELO USUARIO
SELECT *
FROM SYSTYPES
CREATE TYPE TIPO_ENDERECO
FROM VARCHAR(60) NOT NULL
--ASSOCIAR O TIPO DE DADOS AO CAMPO DA TABELA
CREATE TABLE PESSOA
(COD INT PRIMARY KEY
,NOME TIPO_NOME
,ENDERECO TIPO_ENDERECO
,CNPJ BIGINT
)
--VISUALIZAR A ESTRUTURA DA TABELA
EXEC SP_HELP PESSOA
--EXERCICIO
--CRIAR UM BANCO DE DADOS COM O NOME TESTE_UDDT
CREATE DATABASE TESTE_UDDT
USE TESTE_UDDT
--CRIAR OS TIPOS DE DADOS: TYPE_NOME_PESSOA, TYPE_NOME_EMPRESA
--TYPE_PRECO, TYPE_SN, TYPE_DATA_MOVTO
CREATE TYPE TYPE_NOME_PESSOA
FROM VARCHAR(60) NOT NULL

CREATE TYPE TYPE_NOME_EMPRESA
FROM VARCHAR(60) NOT NULL

CREATE TYPE TYPE_PRECO
FROM NUMERIC(12,2)

CREATE TYPE TYPE_SN
FROM CHAR(1) NOT NULL

CREATE TYPE TYPE_DATA_MOVTO
FROM DATETIME NOT NULL

SELECT *
FROM SYSTYPES
WHERE UID=1
--REGRAS DE VALIDAÇÃO
--O PRECO NÃO PODE SER NEGATIVO
CREATE RULE R_PRECO AS @PRECO>=0
GO
CREATE RULE R_SN AS @SN IN('S','N')
GO
CREATE RULE R_DATA_MOVTO AS @DT <= GETDATE()

SELECT *
FROM SYSOBJECTS
WHERE XTYPE='R'


SELECT *
FROM SYSCOMMENTS

SELECT NAME
      ,TEXT
FROM SYSOBJECTS AS OBJ
INNER JOIN SYSCOMMENTS AS S
ON OBJ.ID=S.ID
WHERE OBJ.XTYPE='R'
-----------------------------------------------------------
--ASSOCIAR A REGRA AO TIPO DE DADOS
EXEC SP_BINDRULE 'R_PRECO','TYPE_PRECO'
EXEC SP_BINDRULE 'R_SN','TYPE_SN'
EXEC SP_BINDRULE 'R_DATA_MOVTO','TYPE_DATA_MOVTO'
------------------------------------------------------------
--O TIPO DE DADOS SN DEVE RECEBER POR DEFAULT A LETRA 'S'
CREATE DEFAULT DEF_SN AS 'S'
GO
--DATA_MOVTO POR DEFAULT RECEBE GETDATE()
CREATE DEFAULT DEF_DATA_MOVTO AS GETDATE()
-------------------------------------------------------------
--ASSOCIAR O DEFAULT AO TIPO DE DADOS
EXEC SP_BINDEFAULT 'DEF_SN', 'TYPE_SN'
EXEC SP_BINDEFAULT 'DEF_DATA_MOVTO', 'TYPE_DATA_MOVTO'
--------------------------------------------------------------
CREATE TABLE PRODUTOS
( COD_PROD INT IDENTITY(1,1),
DESCRICAO VARCHAR(80),
PRECO_CUSTO TYPE_PRECO,
PRECO_VENDA TYPE_PRECO,
DATA_CADASTRO TYPE_DATA_MOVTO,
SN_ATIVO TYPE_SN,
CONSTRAINT PK_PRODUTOS PRIMARY KEY (COD_PROD) )
--TESTAR OS TIPOS DE DADOS
INSERT INTO PRODUTOS( DESCRICAO, PRECO_CUSTO, PRECO_VENDA )
VALUES( 'TESTE 1', 10.50, 2.58 )

INSERT INTO PRODUTOS( DESCRICAO, PRECO_CUSTO, PRECO_VENDA
                      ,DATA_CADASTRO )
VALUES( 'TESTE 2', 10.50, 2.58,'2019/05/17' )

INSERT INTO PRODUTOS( DESCRICAO, PRECO_CUSTO, PRECO_VENDA
                      ,DATA_CADASTRO,SN_ATIVO  )
VALUES( 'TESTE 3', 0.50,1.5,GETDATE(),'N' )
SELECT *
FROM PRODUTOS
-----------------------------------------------------------------
CREATE SEQUENCE SEQ_ALUNO
START WITH 1000
INCREMENT BY 10
MINVALUE 10
MAXVALUE 10000
CYCLE CACHE 10

CREATE TABLE T_ALUNO
(COD_ALUNO INT,
NOM_ALUNO VARCHAR(50) )
SELECT *
FROM T_ALUNO

INSERT INTO T_ALUNO (COD_ALUNO, NOM_ALUNO)
VALUES (NEXT VALUE FOR DBO.SEQ_ALUNO, 'TESTE2')

CREATE SYNONYM TESTE_AL FOR DBO.T_ALUNO
SELECT *
FROM TESTE_AL
-----------------------------------------------------------------
--CAPITULO 4
--PLANO DE EXECUÇÃO
USE PEDIDOS
SELECT *
FROM TB_PRODUTO

SELECT D.DEPTO , E.NOME
FROM TB_DEPARTAMENTO AS D
JOIN TB_EMPREGADO AS E 
ON E.COD_DEPTO = D.COD_DEPTO
ORDER BY E.NOME


MERGE EMP_TEMP AS EMP
USING TB_EMPREGADO AS TB_EMP
ON EMP.CODFUN=TB_EMP.CODFUN
WHEN MATCHED AND EMP.SALARIO<>TB_EMP.SALARIO THEN
UPDATE
SET EMP.SALARIO=TB_EMP.SALARIO

WHEN NOT MATCHED THEN
INSERT (CODFUN,NOME,COD_DEPTO
       ,COD_CARGO,DATA_ADMISSAO
       ,DATA_NASCIMENTO,SALARIO
       , NUM_DEPEND, SINDICALIZADO
       , OBS, FOTO)
VALUES (CODFUN,NOME,COD_DEPTO
        ,COD_CARGO,DATA_ADMISSAO
        ,DATA_NASCIMENTO,SALARIO
        , NUM_DEPEND, SINDICALIZADO
        , OBS, FOTO);

 
----CAP 5--OPENROWSET---------
EXEC sp_configure 'show advanced option', '1';
reconfigure

exec sp_configure 'Ad Hoc Distributed Queries',1
reconfigure

USE Pedidos

SELECT * 

FROM PESSOA

DELETE FROM PESSOA

----CONSUULTAR A PLANILHA PESSOAS.XLSX
SELECT * FROM OPENROWSET('Microsoft.ACE.OLEDB.12.0',
'Excel 12.0;Database=C:\DADOS\PESSOA.XLSX',
'SELECT COD, NOME FROM [NOMES$]')

---IMPORTAR OS DADOS DE EXCEL PARA O SQL

INSERT INTO PESSOA
SELECT * FROM OPENROWSET('Microsoft.ACE.OLEDB.12.0',
'Excel 12.0;Database=C:\DADOS\PESSOA.XLSX',
'SELECT COD, NOME FROM [NOMES$]')
SELECT * FROM PESSOA


---------EXPORTAR OS DADOS PARA EXCEL DO SQL

INSERT INTO OPENROWSET('Microsoft.ACE.OLEDB.12.0',
'Excel 12.0;Database=C:\DADOS\PESSOA.XLSX',
'SELECT COD, NOME FROM [NOMES$]')
SELECT * FROM PESSOA

INSERT INTO OPENROWSET('Microsoft.ACE.OLEDB.12.0',
'Excel 12.0;Database=C:\DADOS\PESSOA.XLSX',
'SELECT COD, NOME FROM [NOMES$]')
SELECT * FROM PESSOA

SELECT * FROM OPENROWSET('Microsoft.ACE.OLEDB.12.0',
'Excel 8.0;Database=C:\DADOS\PESSOA.XLS',
'SELECT COD, NOME FROM [NOMES$]');
SELECT * FROM PESSOA


---CRIAR TABELA TIPOPRODUTO
CREATE TABLE TIPOPRODUTO
(COD_TIPO INT PRIMARY KEY, TIPO VARCHAR(30))

---IMPORTAR DADOS DO ACESS (TIPOPRODUTO)
INSERT INTO TIPOPRODUTO(COD_TIPO,TIPO)
SELECT *
FROM  OPENROWSET (MICROSOFT.ACE.OLEDB.12.0

CREATE TABLE TESTE_BULK_INSERT
( CODIGO INT,
NOME VARCHAR(40),
DATA_NASCIMENTO DATETIME )

BULK INSERT TESTE_BULK_INSERT
FROM 'C:\DADOS\BULK_INSERT.txt'
WITH
(
FIELDTERMINATOR =';',
ROWTERMINATOR = '\n',
codepage = 'acp'
)

SELECT *
FROM OPENROWSET('Microsoft.ACE.OLEDB.12.0',
'C:\Dados\Pedidos.accdb';
'admin';'',PEDIDOS)

SELECT P.*, C.NOME
FROM OPENROWSET('Microsoft.ACE.OLEDB.12.0',
'C:\Dados\Pedidos.accdb';
'admin';'',PEDIDOS) P
JOIN PEDIDOS.DBO.TB_CLIENTE C ON P.CODCLI = C.CODCLI

SELECT * FROM TIPOPRODUTO

CREATE TABLE TIPOPRODUTO
(COD_TIPO INT PRIMARY KEY, TIPO VARCHAR(30))

INSERT INTO TIPOPRODUTO
SELECT *
FROM OPENROWSET('Microsoft.ACE.OLEDB.12.0',
'C:\Dados\Pedidos.accdb';
'admin';'',TIPOPRODUTO)

SELECT * FROM TIPOPRODUTO

CREATE TABLE TESTE_BULK_INSERT
( CODIGO INT,
NOME VARCHAR(40),
DATA_NASCIMENTO DATETIME )
-- Execução do comando BULK INSERT

BULK INSERT TESTE_BULK_INSERT
FROM 'C:\DADOS\BULK_INSERT.txt'
WITH
(
FIELDTERMINATOR =';',
ROWTERMINATOR = '\n',
codepage = 'acp'
)

SELECT * FROM TESTE_BULK_INSERT

---GERAR XML

SELECT NOME, DATA_ADMISSAO, SALARIO

FROM TB_EMPREGADO

FOR XML RAW

------------------- LINHAS E RAIZ

SELECT NOME, DATA_ADMISSAO, SALARIO

FROM TB_EMPREGADO
-- tag da linha , tag principal
FOR XML RAW('Produto'), ROOT('Produtos')

SELECT NOME, DATA_ADMISSAO, SALARIO

FROM TB_EMPREGADO
ORDER BY SALARIO
FOR XML RAW('Produto'), ROOT('Produtos'), ELEMENTS


----------NULABILIDADE DE CAMPOS DE UM PREGISTRO


SELECT NOME, DATA_ADMISSAO, SALARIO

FROM TB_EMPREGADO
ORDER BY SALARIO
FOR XML RAW('Produto'), ROOT('Produtos'), ELEMENTS XSINIL

---------XML AUTO com tag raiz e um elemento para cada campo


SELECT EMP.CODFUN, EMP.NOME, EMP.DATA_ADMISSAO, EMP.SALARIO
FROM TB_EMPREGADO AS EMP
ORDER BY SALARIO
FOR XML AUTO, ROOT('Produtos'), ELEMENTS XSINIL



-- o nome da coluna dá nome ao elemento de cada campo
SELECT Empregado.CODFUN AS Codigo, Empregado.NOME, Empregado.DATA_
ADMISSAO, Empregado.SALARIO
-- o apelido da tabela dá nome à tag de linha
FROM TB_EMPREGADO Empregado
FOR XML AUTO, ROOT('Empregados'), ELEMENTS XSINIL


----------------------------------------------------------------------------

SELECT Empregado.CODFUN, Empregado.NOME, Empregado.DATA_ADMISSAO,
Empregado.SALARIO, Dependente.CODDEP, Dependente.NOME, Dependente.
DATA_NASCIMENTO
FROM TB_EMPREGADO Empregado JOIN TB_DEPENDENTE Dependente ON
Empregado.CODFUN = Dependente.CODFUN
FOR XML AUTO, ROOT('Empregados'), ELEMENTS XSINIL

---------------------------------------

SELECT
Cliente.CODCLI AS IdCliente, Cliente.NOME AS Cliente,
Pedidos.NUM_PEDIDO AS IdPedido, Pedidos.VLR_TOTAL AS VlrPedido,
Pedidos.DATA_EMISSAO AS Emissao
FROM TB_CLIENTE Cliente JOIN TB_PEDIDO Pedidos ON Cliente.CODCLI =
Pedidos.CODCLI
WHERE Pedidos.DATA_EMISSAO BETWEEN '2014.1.1' AND '2014.1.31'
FOR XML AUTO, ROOT('Clientes')

----------------------------------------------------------------------

SELECT
Cliente.CODCLI AS IdCliente, Cliente.NOME AS Cliente,
Pedidos.NUM_PEDIDO AS IdPedido,
Pedidos.VLR_TOTAL AS VlrPedido, Pedidos.DATA_EMISSAO AS Emissao
FROM TB_CLIENTE Cliente JOIN TB_PEDIDO Pedidos ON Cliente.CODCLI =
Pedidos.CODCLI
WHERE Pedidos.DATA_EMISSAO BETWEEN '2014.1.1' AND '2014.1.31'
FOR XML AUTO, ROOT('Clientes'), ELEMENTS

--XML AUTO com tag raiz, um elemento para cada campo e com lista de
--subitens (mestre x detalhe de três níveis)
SELECT
Cliente.CODCLI AS IdCliente, Cliente.NOME AS Cliente,
Pedidos.NUM_PEDIDO AS IdPedido,
Pedidos.VLR_TOTAL AS VlrPedido, Pedidos.DATA_EMISSAO AS Emissao,
Itens.NUM_ITEM AS IdItem, Itens.ID_PRODUTO AS IdProduto,
Itens.QUANTIDADE AS Quantidade, Itens.PR_UNITARIO AS PrUnitario
FROM TB_CLIENTE Cliente
JOIN TB_PEDIDO Pedidos ON Cliente.CODCLI = Pedidos.CODCLI
JOIN TB_ITENSPEDIDO Itens ON Pedidos.NUM_PEDIDO = Itens.NUM_PEDIDO
WHERE Pedidos.DATA_EMISSAO BETWEEN '2014.1.1' AND '2014.1.31'
-- Importante para ter um resultado correto
ORDER BY Cliente.NOME, Pedidos.NUM_PEDIDO
FOR XML AUTO, ROOT('Clientes')


-------------------------------------------------------------------------

---XML EXPLICIT (XML é montado explicitamente no comando SELECT)

SELECT 1 AS Tag, NULL AS Parent,
-- conteúdo tag id atributo -->> <Empregado
Codigo="1"
CODFUN [Empregado!1!Codigo],
-- dentro da tag Empregado criar elemento "Nome"
NOME AS [Empregado!1!Funcionario!ELEMENT],
-- dentro da tag Empregado criar elemento "Salario"
SALARIO [Empregado!1!Renda!ELEMENT],
-- dentro da tag Empregado criar elemento "DataAdm"
DATA_ADMISSAO [Empregado!1!DataAdm!ELEMENT]
FROM TB_EMPREGADO
ORDER BY CODFUN
FOR XML EXPLICIT, ROOT('Empregados')


-----EXERCICIO

SELECT
	Cliente.CODCLI AS IdCliente, 
	Cliente.NOME AS Cliente,
	Pedidos.NUM_PEDIDO AS IdPedido, 
	Pedidos. AS VlrPedido,
	Pedidos.VLR_TOTAL AS VlrPedido,
	Pedidos.DATA_EMISSAO AS Emissao
FROM TB_CLIENTE Cliente JOIN TB_PEDIDO Pedidos ON Cliente.CODCLI =
Pedidos.CODCLI
cod_ped.tb_pedidos JOIN descricao ON Cliente.CODCLI =
Pedidos.CODCLI
FOR XML AUTO, ROOT('Clientes')


select NOME,
	   PED.NUM_PEDIDO,
	   DATA_EMISSAO,
	   sUM (QUANTIDADE+PR_UNITARIO
FROM TB_PEDIDO AS PED
INNER JOIN TB_CLIENTE AS CLI
ON CLI.CODCLI=PED.CODCLI
INNER JOIN TB_ITENSPEDIDO AS ITEM
ON PED.NUM_PEDIDO=ITEM.NUM_PEDIDO
INNER JOIN TB_PRODUTO AS PROD
ON PROD.ID_PRODUTO=ITEM.ID_PROD
ORDER BY Cliente.NOME, Pedido.NUM_PEDIDO
FOR XML AUTO, ROOT('Clientes')


SELECT 1 AS Tag, 
		NULL AS Parent,
		CODFUN [Empregado!1!NUMERO],
		NOME AS [Empregado!1!Funcionario!ELEMENT],
		SALARIO AS [Empregado!1!SALARIO!ELEMENT]
FROM TB_EMPREGADO
FOR XML EXPLICIT, ROOT('Empregados')

SELECT 1 AS TAG, NULL AS PARENT,
-- gera a tag principal no primeiro nível
'' [Empregados!1],
-- define o restante da estrutura do XML
NULL AS [Empregado!2!CODFUN],
NULL AS [Empregado!2!Nome!ELEMENT],
NULL [Empregado!2!Salario!ELEMENT],
NULL [Empregado!2!DataAdm!ELEMENT]
UNION ALL
-- fornece os dados definidos na estrutura anterior
-- Tag de nível 2, o parent desta Tag é a Tag do nível anterior
SELECT 2 AS Tag, 1 AS Parent, NULL,
CODFUN,
NOME,
SALARIO,
DATA_ADMISSAO
FROM TB_EMPREGADO
FOR XML EXPLICIT , ROOT('Empregados')



--variavel (@)
--RECLARAR UMA VARIAVEL INTEIRA

DECLARE @VALOR INT
SET @VALOR=10
SELECT @VALOR
--PRINT @VALOR

--A VARIAVEL @SALARIO DEVE ARMAZENAR O SALARIO DO FUNCIONARIO DE CODIGO 5

DECLARE @SALARIO NUMERIC(18,2)
SET @SALARIO=(SELECT SALARIO 
FROM TB_EMPREGADO WHERE CODFUN=5)
--SELECT @SALARIO
PRINT @SALARIO

----Query
---Este método permite a consulta em uma estrutura XML. Veja os exemplos adiante:
-- Declarando uma variável XML
DECLARE @XML XML
-- Carrega as informações da consulta para a variável XML,
---utilizando o FOR XML:
SET @XML =
(
SELECT CODFUN, NOME, DATA_ADMISSAO
FROM TB_EMPREGADO AS EMPREGADO
FOR XML AUTO, ELEMENTS
)
SELECT @XML.query('EMPREGADO/DATA_ADMISSAO'

)

--A consulta adiante retorna o campo NOME do primeiro registro:
DECLARE @XML XML
SET @XML =
(SELECT CODFUN, NOME, DATA_ADMISSAO FROM TB_EMPREGADO
AS EMPREGADO
FOR XML AUTO, ELEMENTS )
SELECT @XML.value('(EMPREGADO/NOME)[1]', 'varchar(100)')

--A consulta adiante verifica se existe o campo CODFUN:
DECLARE @XML XML
SET @XML =
(SELECT CODFUN, NOME, DATA_ADMISSAO FROM TB_EMPREGADO
AS EMPREGADO
FOR XML AUTO, ELEMENTS )
SELECT @XML.exist('EMPREGADO/CODFUN' )

--A consulta adiante verifica se existe o campo CODFUN:
DECLARE @XML XML
SET @XML =
(SELECT CODFUN, NOME, DATA_ADMISSAO FROM TB_EMPREGADO
AS EMPREGADO
FOR XML AUTO, ELEMENTS )
--SELECT @XML.exist('EMPREGADO/CODFUN' )

--Consulta que verifica se existe o registro 35 e o retorno será 1:
--...
SELECT @XML.exist('(EMPREGADO/CODFUN)[35]' )

------Ao alterar o valor para 3500, o retorno será 0, pois não encontrou o registro
--correspondente:
--...
SELECT @XML.exist('(EMPREGADO/CODFUN)[3500]' )

--Junto com o comando CASE:
--...
SELECT CASE @XML.exist('(EMPREGADO/CODFUN)[3500]' )
WHEN 0 THEN 'Não EXISTE'
WHEN 1 THEN 'EXISTE' END

--O comando BCP permite a importação e exportação de arquivos para o SQL Server.
--O BCP é executado no prompt de comando
sp_configure 'xp_cmdshell',1
go
reconfigure


DECLARE @CMD VARCHAR(4000)
SET @CMD =
'BCP "SELECT * FROM PEDIDOS.DBO.TB_TIPOPRODUTO AS TIPO FOR XML AUTO,ROOT(''RESULTADO''), ELEMENTS " '+' QUERYOUT "C:\DADOS\ARQUIVOXML.XML"-t -w -t -T'
EXEC MASTER..XP_CMDSHELL @CMD


----5.4.4. Abrindo um arquivo XML
----A consulta de um arquivo XML
SELECT
X.TIPO.query('COD_TIPO').value('.', 'INT'),
X.TIPO.query('TIPO').value('.', 'VARCHAR(30)')
FROM (SELECT CAST(X AS XML)
FROM OPENROWSET(
BULK 'C:\DADOS\ARQUIVOXML.XML-t',
SINGLE_BLOB) AS T(X)
) AS T(X)
CROSS APPLY X.nodes('RESULTADO/TIPO') AS X(TIPO);


-----------GERAR ARQUIVO JSON

SELECT Empregado.CODFUN AS Codigo, Empregado.NOME, Empregado.DATA_ADMISSAO, Empregado.SALARIO
FROM TB_EMPREGADO Empregado
FOR JSON AUTO, ROOT('Empregados')

----Vejamos um exemplo com vários campos e ROOT Clientes:
SELECT  Cliente.CODCLI AS IdCliente, 
		Cliente.NOME AS Cliente, 
		Pedidos.NUM_PEDIDO AS IdPedido,
		Pedidos.VLR_TOTAL AS VlrPedido, 
		Pedidos.DATA_EMISSAO AS Emissao
FROM TB_CLIENTE Cliente JOIN TB_PEDIDO Pedidos ON Cliente.CODCLI =
Pedidos.CODCLI
WHERE Pedidos.DATA_EMISSAO BETWEEN '2013.1.1' AND '2013.1.01'
FOR JSON PATH, ROOT('Clientes')


---OPENJSON
---PARA COMANDOS DO JSON EXECUTAR É NECESSARIO A COMPATIBILADADE--130

SELECT *
FROM SYS.DATABASES
ALTER DATABASE PEDIDOS
SET COMPATIBILITY_LEVEL=130

SELECT *
FROM OPENJSON('[{"IdCliente":617,"Cliente":"ADALBERTO M. CABRAL"}]')

--Vejamos, adiante, a execução de uma consulta simples com OPENJSON:
SELECT * 
FROM OPENJSON('["São Paulo", 
				"Rio de Janeiro", 
				"Minas Gerais", 
				"Paraná", 
				"Santa Catarina"]')

-----Neste exemplo, será criada uma variável JSON e carregado um valor para ser lido com
-----a função JSON:
DECLARE @json NVARCHAR(4000)
SET @json = N'{
"CODCLI": 1,
"NOME": "IMPACTA Treinamento"}'
SELECT * FROM OPENJSON(@json) AS CLIENTE;

---Informando os campos KEY e Value:
DECLARE @json NVARCHAR(4000)
SET @json = N'{
"CODCLI": 1,
"NOME": "IMPACTA Treinamento"}'
SELECT [KEY], Value FROM OPENJSON(@json) AS CLIENTE;

---Apresentando somente o campo Nome:
DECLARE @json NVARCHAR(4000)
SET @json = N'{
"CODCLI": 1,
"NOME": "IMPACTA Treinamento"}'
SELECT [KEY], Value FROM OPENJSON(@json) AS CLIENTE

----JSON_VALUE permite extrair um valor diretamente do caminho especificado. No
----exemplo adiante, serão apresentados os campos NOME e CODCLI:
DECLARE @json NVARCHAR(4000)
SET @json = N'{
"CODCLI": 1,
"NOME": "IMPACTA Treinamento"}'
-- Campo Nome
SELECT JSON_VALUE(@json, '$.NOME') AS NOME
-- Campo CODCLI
SELECT JSON_VALUE(@json, '$.CODCLI') AS CODCLI

--No exemplo a seguir, são utilizados colchetes para selecionar qual linha será
--apresentada:
DECLARE @json NVARCHAR(4000)
SET @json = N'
{"CLIENTES":[
{"CODCLI":1,"NOME":"IMPACTA Treinamento"},
{"CODCLI":2,"NOME":"FACULDADE IMPACTA"}
]}'
SELECT JSON_VALUE(@json, '$.CLIENTES[0].NOME') AS NOME
SELECT JSON_VALUE(@json, '$.CLIENTES[1].NOME') AS NOME

--No exemplo adiante, será utilizada uma matriz e restaurado o segundo valor:
DECLARE @json NVARCHAR(4000)
SET @json = N'{
"CODCLI": 1,
"NOME": "IMPACTA Treinamento",
"FONE":["(11)3342-1234","(11)3342-1235"]}'
SELECT JSON_VALUE(@json, '$.FONE[1]') AS FONE

--JSON_QUERY retorna uma parte ou matriz de um JSON.
--A consulta adiante retorna as informações da matriz FONE:
DECLARE @json NVARCHAR(4000)
SET @json = N'{
"CODCLI": 1,
"NOME": "IMPACTA Treinamento",
"FONE":["(11)3342-1234", "(11)3342-1235"]}'
SELECT JSON_QUERY(@json, '$.FONE') AS FONE

--No exemplo a seguir, são apresentadas todas as informações do JSON:
DECLARE @json NVARCHAR(4000)
SET @json = N'{"CLIENTES":[
{"CODCLI":1,"NOME":"IMPACTA Treinamento"},
{"CODCLI":2,"NOME":"FACULDADE IMPACTA"}
]}'
SELECT JSON_QUERY(@json, '$') a




