--COLOCAR EM USO O BANCO PEDIDOS
USE PEDIDOS
--SCHEMABINDING --> PROTEGE A ESTRUTURA DA TABELA
--NA CONSTRUÇÃO DA VIEW É NECESSARIO INFORMAR O SCHEMA DA 
--TABELA
CREATE VIEW VW_RELAT_EMP 
WITH SCHEMABINDING
AS
SELECT CODFUN
              , NOME
             , COD_DEPTO
             , COD_CARGO
             , NUM_DEPEND
             , SALARIO
FROM DBO.TB_EMPREGADO
-----------------------------------------------------------------------------------------------------------
SELECT *
FROM VW_RELAT_EMP
--APAGAR A COLUNA NUM_DEPEND
ALTER TABLE TB_EMPREGADO 
DROP COLUMN NUM_DEPEND
GO
------------------------------------------------------------------------------------------------------------
SELECT *
FROM TB_EMPREGADO
------------------------------------------------------------------------------------------------------------
--APAGAR A COLUNA FOTO
ALTER TABLE TB_EMPREGADO
DROP COLUMN FOTO
-----------------------------------------------------------------------------------------------------------
--CRIAR INDICE NA VISAO(VIEW)
--CRIAR UM INDICE PARA O CAMPO CODFUN
CREATE UNIQUE CLUSTERED INDEX NDX_CODFUN
ON VW_RELAT_EMP(CODFUN)

CREATE NONCLUSTERED INDEX NDX_NOME 
ON VW_RELAT_EMP(NOME)

SELECT NOME
              ,SALARIO
FROM VW_RELAT_EMP
WHERE NOME LIKE 'C%'
----------------------------------------------------------------------------------------------------------------
--INSERIR DADOS NA TABELA EMPREGADO POR MEIO DA VISAO
CREATE VIEW VW_INSERE_EMP
AS
SELECT CODFUN
              , NOME
              , DATA_ADMISSAO
							,COD_DEPTO
							, COD_CARGO
							, SALARIO
FROM TB_EMPREGADO
WHERE COD_DEPTO = 2

--INSERT NA TABELA EMPREGADO 
INSERT INTO TB_EMPREGADO(NOME,DATA_ADMISSAO
                                                           ,COD_DEPTO,COD_CARGO,SALARIO)
VALUES('TURMA SABADO','2019/05/18',1,5,8.500)
--------------------------------------------------------------------------------------------------------
--INSERIR REGISTRO POR MEIO DA VISAO
INSERT INTO VW_INSERE_EMP(NOME,DATA_ADMISSAO
                                                           ,COD_DEPTO,COD_CARGO,SALARIO)
VALUES('TURMA DOMINGO','2019/05/19',1,7,7755)

SELECT *
FROM TB_EMPREGADO
SELECT *
FROM VW_INSERE_EMP
------------------------------------------------------------------------------------------------------
ALTER VIEW VW_INSERE_EMP
AS
SELECT CODFUN
              , NOME
              , DATA_ADMISSAO
							,COD_DEPTO
							, COD_CARGO
							, SALARIO
FROM TB_EMPREGADO
WHERE COD_DEPTO = 2
WITH CHECK OPTION

INSERT INTO VW_INSERE_EMP(NOME,DATA_ADMISSAO
                                                           ,COD_DEPTO,COD_CARGO,SALARIO)
VALUES('TURMA SEMANA','2019/05/20',2,2,3000)
-----------------------------------------------------------------------------------

--exercicio1 criar uma view para retornar o numero do pedido
--o numero do item, o id_produto, cod_tipo pr_unitario
--filtro:cod_tipo=5
CREATE VIEW VW_PED_3
AS
 SELECT NUM_PEDIDO,
    	NUM_ITEM,
		ID_PRODUTO, 
		PR_UNITARIO
FROM TB_ITENSPEDIDO
WHERE ID_PRODUTO=5
WITH CHECK OPTION

SELECT * 
FROM  VW_PED_3

--exercicio 2: eserir dadis por meio da view na tabela
--tb_itenspedido

SELECT *
FROM VW_PED_3
INSERT TB_PEDIDO 
VALUES (108,5,GETDATE(),1000,'P',NULL)
-----------------------------------------------------------
INSERT INTO VW_PED_3(NUM_PEDIDO,
    				 NUM_ITEM,
					 ID_PRODUTO, 
					 PR_UNITARIO)
VALUES(11323,2,5,500)
------------------------------------------------
-- 2. Criar VIEW (VIE_TOT_VENDIDO) para mostrar o total vendido (soma de TB_PEDIDO.VLR_TOTAL)
-- em cada mês do ano. Deve mostrar o mês, o ano e o total vendido
-- Resp.:
GO
CREATE VIEW VW_TOT_VENDIDO AS
SELECT MONTH( DATA_EMISSAO ) AS MES,
       YEAR( DATA_EMISSAO ) AS ANO,
       SUM( VLR_TOTAL ) AS TOT_VENDIDO
FROM TB_PEDIDO
GROUP BY MONTH(DATA_EMISSAO), YEAR(DATA_EMISSAO)

SELECT *
FROM VW_TOT_VENDIDO


SELECT * 
FROM SYSCOMMENTS

-- 4. Criar VIEW (VIE_MAIOR_PEDIDO) para mostrar valor do maior pedido (MAX de TB_PEDIDO.VLR_TOTAL)
-- vendido em cada mês do ano. Deve mostrar o mês, o ano e o maior pedido
CREATE VIEW VW_MAIOR_PEDIDO AS
SELECT MONTH( DATA_EMISSAO ) AS MES,
       YEAR( DATA_EMISSAO ) AS ANO,
       MAX( VLR_TOTAL ) AS MAIOR_PEDIDO
FROM TB_PEDIDO
WHERE YEAR(DATA_EMISSAO) = 2014
GROUP BY MONTH(DATA_EMISSAO), YEAR(DATA_EMISSAO)
GO
SELECT *
FROM VW_TOT_VENDIDO
-----------------------------------------------------
-- 6. Faça um JOIN, utilizando VIE_MAIOR_PEDIDO e PEDIDOS que mostre também o número
-- do pedido (TB_PEDIDO.NUM_PEDIDO) de maior valor em cada mês. Deve filtrar o ano
-- de 2014 e ordernar por mês.
-- Resp.:
SELECT V.MES, V.ANO, V.MAIOR_PEDIDO, P.NUM_PEDIDO
FROM VW_MAIOR_PEDIDO V 
     JOIN TB_PEDIDO P ON V.MES = MONTH(P.DATA_EMISSAO) AND
                       V.ANO = YEAR(P.DATA_EMISSAO) AND
                       V.MAIOR_PEDIDO = P.VLR_TOTAL
WHERE V.ANO = 2014                       
ORDER BY MES

------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------
--CAP7
--VARIAVEIS (@-->VARIAVEL LOCAL
--                       @@--> VARIAVEL GLOBAL)
--SOMAR DOIS NUMEROS INTEIROS
--DECLARACOA DE VARIAVEIS
DECLARE @P_VALOR INT
                   ,@S_VALOR INT
                   ,@SOMA INT
--ATRIBUIR VALORES
SET @P_VALOR=10
SET @S_VALOR=32
SET @SOMA=@P_VALOR + @S_VALOR
PRINT @SOMA
IF @P_VALOR > @S_VALOR
  BEGIN
    PRINT 'MAIOR:'+CAST(@P_VALOR AS CHAR(2))
    PRINT 'FIM'
END
ELSE
   PRINT CONCAT('MAIOR:',@S_VALOR)
-----------------------------------------------------------------------------------------------------------
--CONCATENAÇÃO (+)
SELECT ENDERECO + ' - '+CIDADE
FROM TB_CLIENTE

SELECT  NOME+' : '+ CAST(COD_DEPTO AS CHAR(3))
FROM TB_EMPREGADO

--CONCAT
SELECT CONCAT(NOME,' :',COD_DEPTO)
FROM TB_EMPREGADO
----------------------------------------------------------------------------------------------------------
--FAZER UM PROGRAMA PARA RECEBER UMA DATA E RETORNAR O DIA
--DA SEMANA POR EXTENSO(USAR IF/ELSE)

DECLARE @DATA DATETIME
                  ,@DIA INT
SET @DATA='2018/12/25'
SET @DIA=DATEPART(WEEKDAY,@DATA)

IF @DIA=1
	PRINT 'DOMINGO'
ELSE IF @DIA=2
	PRINT 'SEGUNDA-FEIRA'
ELSE IF @DIA=3
	PRINT 'TERÇA-FEIRA'
ELSE IF @DIA=4
	PRINT 'QUARTA-FEIRA'
ELSE IF @DIA=5
	PRINT 'QUNTA-FEIRA'
ELSE IF @DIA=6
	PRINT 'SEXTA-FEIRA'
ELSE IF @DIA=7
	PRINT 'SABADO'


--WHILE(ENQUANTO)

	DECLARE @CONT INT
	SET @CONT =0
	WHILE @CONT < 5
	BEGIN
	SET @CONT= @CONT + 1
	PRINT @CONT
	END

--FAZER UM PROGRAMA PARA EXIBIR O CODIGO DO FUNCIONARIO E O NOME
--NO INTERVALO DE 1 A 7

DECLARE @CONT INT
	SET @CONT =1
	WHILE @CONT < 5
	BEGIN
	SELECT CODFUN, NOME
	FROM TB_EMPREGADO
	SET @CONT= @CONT + 1
	PRINT @CONT
	END


------------------------------------
CREATE PROCEDURE SP_CONSULTA_EMP @COD INT
AS
BEGIN
SELECT CODFUN, NOME
FROM TB_EMPREGADO
WHERE CODFUN=@COD
END
EXEC SP_CONSULTA_EMP 5

-- CRIAR UMA PROC PARA RETORNAR OS PEDIDOS E DATA_EMISSAO
--NO PERIODO DE JANEIRO/2014

CREATE PROCEDURE SP_CONSULTA_PEDIDOS @DATAINI DATETIME, @DATAFIM DATETIME
AS
BEGIN
SELECT NUM_PEDIDO, DATA_EMISSAO
FROM TB_PEDIDO
WHERE DATA_EMISSAO BETWEEN @DATAINI AND @DATAFIM
END
EXEC SP_CONSULTA_PEDIDOS '2014/01/01','2014/01/31'
PRINT SP_CONSULTA_PEDIDOS
SELECT *
FROM SP_CONSULTA_PEDIDOS


--CRIAR TABELA MEGA SENA

CREATE TABLE SP_MEGA_SENA

------CRIAR UM PROGRAMA PARA GERAR 6 NUMEROS ALEATORIOS 
--GERAR NUMERO ALEATORIO

DECLARE @DEZENA INT, @CONT INT = 1;
IF OBJECT_ID('TBL_MEGASENA') IS NOT NULL
   DROP TABLE TBL_MEGASENA;
   
CREATE TABLE TBL_MEGASENA( NUM_DEZENA INT );
   
WHILE @CONT <= 6
   BEGIN
   SET @DEZENA = 1 + 60 * RAND();
   IF EXISTS( SELECT * FROM TBL_MEGASENA 
              WHERE NUM_DEZENA = @DEZENA )
      CONTINUE;           
   INSERT INTO TBL_MEGASENA VALUES (@DEZENA);
   SET @CONT += 1;
   END
SELECT * FROM TBL_MEGASENA

-----------------------------------------------------------------------------------
CREATE PROCEDURE SP_GOTO_MEGASENA @DATAINI DATETIME, @DATAFIM DATETIME
AS
BEGIN
SELECT NUM_PEDIDO, DATA_EMISSAO
FROM TB_PEDIDO
WHERE DATA_EMISSAO BETWEEN @DATAINI AND @DATAFIM
END

A:
PRINT 'AGORA ESTOU NO PONTO "A"'
GOTO C
B:
PRINT 'AGORA ESTOU NO PONTO "B"'
GOTO D
C:
PRINT 'AGORA ESTOU NO PONTO "C"'
GOTO B
D:
PRINT 'AGORA ESTOU NO PONTO "D"'
PRINT 'FIM. QUE BAGUNÇA!'

-- RETURN
PRINT 'AGORA ESTOU NO PONTO "A"'
PRINT 'AGORA ESTOU NO PONTO "B"'
RETURN
PRINT 'AGORA ESTOU NO PONTO "C"'
PRINT 'AGORA ESTOU NO PONTO "D"'


----ATRIBUIR A UMA VARIAVEL O VALOR DE UMA CONSULTA
--FAZER UM PROC PARA RECEBERO CODIGO DO FUNCIONARIO E GUARDAR O SALARIO
--EM UMA VARIAVEL

CREATE PROC SP_BUSCA_SALARIO @CODFUN INT
AS
BEGIN
	DECLARE @SALARIO NUMERIC (12,2)
	SET @SALARIO=(SELECT SALARIO
				   FROM TB_EMPREGADO
				   WHERE CODFUN=@CODFUN)
		PRINT @SALARIO
		END
		EXEC SP_BUSCA_SALARIO
---CRIAR UMA PROCEDURE PARA RECEBER O ID_PRODUTO E EXIBIR O NUMERO DO PEDIDO
---NUMERO DO ITEM, QUANTIDADE E PRECO UNITARIO

CREATE PROC SP_BUSCA_DADOSPED @IDPROD INT
AS
BEGIN
SELECT NUM_PEDIDO,
	   NUM_ITEM,
	   QUANTIDADE,
	   PR_UNITARIO		
FROM TB_ITENSPEDIDO
WHERE ID_PRODUTO=@IDPROD
END
EXEC SP_BUSCA_DADOSPED 5


----CRIAR UMA PROC PARA RECEBER O CODCLI E EXIBIR A MENSAGEM SE EXISTE NA TABELA 
--OU NÃO EXISTE NA TABELA

CREATE PROC SP_VERIFICA_CLI @CODCLI INT
AS
BEGIN
	IF EXISTS (SELECT *
			   FROM TB_CLIENTE
			   WHERE CODCLI=@CODCLI)
	SELECT *
	FROM TB_CLIENTE
	WHERE CODCLI=@CODCLI
ELSE
	PRINT 'CLIENTE NÃO CADASTRADO'
END
EXEC SP_VERIFICA_CLI 2


-----------------------------------------------------------------------------------------
--------------CAP 8--------------------------------------------------------------------

--CRIAR UMA FUNÇAO PARA RETORNAR PAR OU IMPAR

CREATE FUNCTION FN_PAR_IMPAR()
	RETURNS VARCHAR (15)
AS
BEGIN
	DECLARE @VALOR INT,
			@RESTO INT,
			@RESULT VARCHAR (15)
	SET @VALOR=5
	SET @RESTO=@VALOR%2
	IF @RESTO=0
		SET @RESULT='PAR'
	ELSE
		SET @RESULT='IMPAR'
END
SELECT DBO.FN_PAR_IMPAR

------------------------------------------------------------------------
---------------------------------
--CRIAR UMA FUNÇAO PARA RECEBER DOIS NUMEROS INTEIROS E 
--DEVOLVER O MAIOR

CREATE TABLE TURISMO




-----------------------------------------------

create proc sp_dados_cli @codcli int
as
begin
	select nome,
		   endereco,
		   cep, LEFT(cep,5) as prim_carac_cep,
				right(cep,3) as ultim_carac_cep
	from tb_cliente
	where codcli=@codcli
end
exec sp_dados_cli 

--com substring

alter proc sp_dados_cli @codcli int
as
begin
	select nome,
		   endereco,
		   cep, 
		   LEFT(cep,5) as prim_carac_cep,
		   right(cep,3) as ultim_carac_cep,
			SUBSTRING (CEP,1,5)AS CEP_SUB,
			SUBSTRING (CEP,6,3) AS CEP_SUB_ULT)
	from tb_cliente
	where codcli=@codcli
end
exec sp_dados_cli 

--CRIAR UMA PROCEDURE PARA RETORNAR O NUMERO DO PEDIDO, A DATA DE EMISSAO
--O TOTAL DE ITENS DE CADA PEDIDO, O NOME DO CLIENTE QUE FEZ O PEDIDO
--O TOTAL DE ITENS DEVE SER FORMATADO COM (,) NAS CASAS DECIMAIS


create proc SP_PEDIDOS

SELECT  PED.NUM_PEDIDO,
		DATA_EMISSÃO,
		REPLACE(FORMAT(QUANTIDADE*PR_UNITARIO,'#####.00')'.',','), AS TOTAL_ITEM,
		NOME
FROM TB_PEDIDO AS PED
INNER JOIN TB_CLIENTE AS CLI
ON PED.CODCLI=CLI.CODCLI
INNER JOIN TB_ITENSPEDIDO AS ITEM
ON PED.NUM_PEDIDO=ITEM.NUM_PEDIDO 

EXEC SP_PEDIDOS


DECLARE @ INTEIRO NUMERIC 18,2
SET @

SELECT ROUND 2
-----------------------------------------------

---CRIAR UMA PROCEDURE PARA INSERIR REGISTRO NA TABELA EMPREGADO
--CAMPOS:NOME,NUM_DEPEND, DATA_NASCIMENTO, COD_DEPTO, COD_CARGO
--DATA_ADMISSAO, SALARIO



create proc SP_




--O exemplo a seguir demonstra o uso de OUTPUT:

ALTER PROCEDURE STP_COPIA_PRODUTO @ID_PRODUTO INT,
@ID_PRODUTO_NOVO INT OUTPUT
AS BEGIN
-- Copia o registro existente para um novo registro
INSERT INTO TB_PRODUTO
( COD_PRODUTO, DESCRICAO, COD_UNIDADE, COD_TIPO, PRECO_CUSTO,
PRECO_VENDA, QTD_ESTIMADA, QTD_REAL, QTD_MINIMA, CLAS_FISC,
IPI, PESO_LIQ )
SELECT COD_PRODUTO, DESCRICAO, COD_UNIDADE, COD_TIPO, PRECO_CUSTO,
PRECO_VENDA, QTD_ESTIMADA, QTD_REAL, QTD_MINIMA, CLAS_FISC,
IPI, PESO_LIQ
FROM TB_PRODUTO
WHERE ID_PRODUTO = @ID_PRODUTO;
-- Descobre qual foi o ID_PRODUTO gerado
SET @ID_PRODUTO_NOVO = SCOPE_IDENTITY();
END
GO
-- Testando
DECLARE @IDPROD INT;
EXEC STP_COPIA_PRODUTO 10, @IDPROD OUTPUT;
PRINT 'NOVO PRODUTO = ' + CAST(@IDPROD AS VARCHAR(5));

----fazer uma proc para exibir em uma variavel de saida o nome do cliente
--apartir do codigo informado

create proc SP_CALCULO @COD INT,
					   @VALOR REAL
AS
BEGIN

DECLARE @RES REAL,
		@SALARIO NUMERIC (18,2)
SET @SALARIO=(SELECT SALARIO
				FROM TB_EMPREGADO
				WHERE CODFUN=@COD)
	SET @RES=@SALARIO*@VALOR
	PRINT @RES
	END
EXEC SP_CALCULO 5,2.5

CREATE TABLE TB_PESSOA
(COD_PES INT PRIMARY KEY,NOME_PES VARCHAR(30),DATA_NASC_PES DATE, END_PES VARCHAR(35), CIDADE VARCHAR(25), ESTADO VARCHAR(2)
)

INSERT INTO TB_PESSOA
VALUES(1,'PABLITO','2010/10/10', 'TANAJURAS STREET', 'TAGAMANDAPIO', 'SP'
)

SELECT *
FROM TB_PESSOA

INSERT INTO TB_PESSOA
VALUES(2,'JUANITA','2003/03/03', 'TATURANAS STREET', 'TMBICOFUMO', 'SP'
)

---ERRO

CREATE PROC 
SP_INSERT_PES @COD_PES INT,
			  @NOME_PES VARCHAR(30),
			  @DATA_NASC_PES DATE, 
			  @END_PES VARCHAR(35), 
			  @CID_PES VARCHAR(25), 
			  @EST_PES VARCHAR(2)
AS
BEGIN
	DECLARE @ERRO INT
	BEGIN TRY
	INSERT INTO TB_PESSOA

AS BEGIN
DECLARE @ERRO INT
INSERT INTO TB_PESSOA

UPDATE TB_PESSOA
VALUES(2,'JUANITA','2003/03/03', 'TATURANAS STREET', 'TIMBOCOFUMO', 'SP'


----CRIAR UMA PROC PARA ATUALIZAR O NOME DO FUNCIONARIO E A DATA DE NASCIMENTO
--SE HOUVER ERRO GRAVAR NA TABELA DE LOG: NUMERO DO ERRO, MENSAGEM DO ERRO
-- LINHA DO ERRO, NIVEL DO ERRO

CREATE TABLE TB_LOG_PES
(NUM_ERRO INT,
MSG_ERRO CHAR(300),
LINHA_ERRO INT,
NIVEL_ERRO INT

USE TB_PESSOA
ALTER TABLE TB_PESSOA
ADD
CONSTRAINT CK_EST CHECK (ESTADO IN ('SP'))



-----CURSOR

DECLARE @COD_SUP INT, @SUPERVISOR VARCHAR(35), @QTD INT
--Declara
DECLARE CURSOR_SUPERVISOR CURSOR FORWARD_ONLY FOR
SELECT DISTINCT COD_SUPERVISOR FROM TB_EMPREGADO WHERE COD_SUPERVISOR IS NOT NULL
-- Abre o Cursor
OPEN CURSOR_SUPERVISOR
-- Movimenta o Cursor para a 1ª linha
FETCH NEXT FROM CURSOR_SUPERVISOR INTO @COD_SUP;



SELECT name
FROM sys.triggers

USE PEDIDOS
CREATE TABLE EMPREGADOS_HIST_SALARIO
( NUM_MOVTO INT IDENTITY,
CODFUN INT,
DATA_ALTERACAO DATETIME,
SALARIO_ANTIGO NUMERIC(12,2),
SALARIO_NOVO NUMERIC(12,2),
CONSTRAINT PK_EMPREGADOS_HIST_SALARIO
PRIMARY KEY (NUM_MOVTO) )




---


CREATE TRIGGER TRG_EMPREGADOS_HIST_SALARIO ON TB_EMPREGADO
FOR UPDATE
AS BEGIN
DECLARE @CODFUN INT, @SALARIO_ANTIGO FLOAT, @SALARIO_NOVO FLOAT;
-- Ler os dados antigos
SELECT @SALARIO_ANTIGO = SALARIO FROM DELETED;
-- Ler os dados novos
SELECT @CODFUN = CODFUN, @SALARIO_NOVO = SALARIO FROM INSERTED;
-- Se houver alteração de salário
IF @SALARIO_ANTIGO <> @SALARIO_NOVO
-- Inserir dados na tabela de histórico
INSERT INTO EMPREGADOS_HIST_SALARIO
(CODFUN, DATA_ALTERACAO, SALARIO_ANTIGO, SALARIO_NOVO)
VALUES
(@CODFUN, GETDATE(), @SALARIO_ANTIGO, @SALARIO_NOVO)
END
-- Testar
UPDATE TB_EMPREGADO SET SALARIO = SALARIO * 1.2
WHERE CODFUN = 3
--
SELECT * FROM EMPREGADOS_HIST_SALARIO
-- Observar que foi inserido na tabela o registro referente à alteração efetuada
-- Alterar o salário "em lote"
UPDATE TB_EMPREGADO SET SALARIO = SALARIO * 1.2
WHERE CODFUN IN (4,5,7)
-- Conferir se foram gerados os históricos para os 3 funcionários
SELECT * FROM EMPREGADOS_HIST_SALARIO

--CRIAR TRIGGER PARA GRAVAR O CODIGO,NOME E SALARIO NO MOMENTO
--QUE OCORREUM INSERT NA TABELA DE EMPREGADO
